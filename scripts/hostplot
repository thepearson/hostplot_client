#!/usr/bin/env python

import sys
import os
import time
import platform
import optparse

try:
  import json
except:
  import simplejson as json

from hostplot.core import Config
from hostplot.core.Api import *
from hostplot.core.Cache import Cache
from hostplot.core.Metrics import Metrics
from hostplot.core.Runner import Runner
from cherrypy.lib.sessions import close
from cookielib import debug

""" Application version number """
APP_VERSION = "0.31"

"""
Some application defaults, most of
these things will be overriden by the
conf file specified at run time.
"""
DEFAULT_APP_NAME = "hostplot"
DEFAULT_METRIC_NAME = "metrics"
DEFAULT_TMP_DIR = '/tmp'
DEFAULT_CONFIG_FILE = "/etc/" + DEFAULT_APP_NAME + ".conf"
DEFAULT_API_PROTOCOL = 'http'
DEFAULT_API_SERVER = "api.hostplot.me"
DEFAULT_API_HOST_PATH='/host'
DEFAULT_API_METRIC_PATH = "/client"
DEFAULT_METRIC_TTL = "30"


"""
Debug levels
"""
DEBUG_NONE = 0
DEBUG_ERROR = 1
DEBUG_WARNING = 2
DEBUG_INFO = 3
DEBUG_DEBUG = 4

""" Current Debug level """
DEBUG_LEVEL = 1

def debug(message, level = DEBUG_ERROR):
  """
  Prints out debug messages
    message = String to print
    level = level to output [default DEBUG_ERROR]
  """
  if DEBUG_LEVEL >= level:
    if level == DEBUG_ERROR:
      l = "DEBUG_ERROR"
    elif level == DEBUG_WARNING:
      l = "DEBUG_WARNING"
    elif level == DEBUG_INFO:
      l = "DEBUG_INFO"
    elif level == DEBUG_DEBUG:
      l = "DEBUG_DEBUG"
    else:
      l = "DEBUG_NONE"
    print l + " :: " + message

def get_version():
  """
  Get application version
    returns Float
  """
  return APP_VERSION

def updateHostInfo(config, model, client = None):
  """
  Updates the host data on the server with local values for
    hostname, client version and platform
  """
  debug("Updating model: " + str(model), DEBUG_DEBUG)
  if client is None:
    debug("Client not specified creating one", DEBUG_DEBUG)
    client = HostApi(config)

  try:
    model['client_version'] = APP_VERSION
    model['hostname'] = platform.node()
    model['platform'] = platform.system()

    debug("Updating client config with client_version: " +
          APP_VERSION + ", hostname: " +
          model['hostname'] + ", platform: " +
          model['platform'], DEBUG_DEBUG)

    host_model = client.updateHostInfo(model)
    debug("Updating host success", DEBUG_DEBUG)
    return True
  except:
    return False

def initialize(config):
  """
  Initializes the host with the API,will also set up the config file
    config Config object
  """
  # get the activation code from the config
  code = config.get('code')

  # set up the host api client
  client = HostApi(config);

  # attempt to activate the host
  obj = client.activateHost(code);

  if obj is None:
    raise Exception("Error activating client, no data returned")

  try:
    if obj['uuid'] is not None:
      config.add('uuid', obj['uuid'])
      updateHostInfo(config, obj, client)
    else:
      raise Exception("Error adding UUID to configuration")
  except:
    raise Exception("Host code is invalid, please try again")

  try:
    config.save()
    return True
  except:
    raise Exception("Couldn't save config")

def update(config):
  """
  Force an update of the host details to the API

  config Config object
  """
  try:
    uuid = config.get('uuid')
    debug("Using uuid: [" + uuid + "]", DEBUG_ERROR)
    client = HostApi(config)
    host_model = client.getHostInfo(uuid)
    debug("Returned model: " + str(host_model), DEBUG_ERROR)
    updateHostInfo(config, host_model, client)
    return True
  except:
    debug("Error updating host config", DEBUG_ERROR)
    return False

def run_command(cmd, config):
  """
  Selectively allows the client to perform some api
  functions manually.
    cmd String command to run [list, info, metrics]
    config Config object
  """
  client = HostApi(config)

  if cmd == 'list':
    print '\t' + '\n\t'.join(['list - this', 'info - show some host info', 'metrics - get host metrics config'])
    return True
  else:
    client = HostApi(config)
    if cmd == 'info':
      print client.getHostInfo(config.get('uuid'))
      return True
    elif cmd == 'metrics':
      print client.getHostConfig()
      return True
    else:
      print "Command not found"
  return False

def collect(config, dry = False):
  """
  Run and collect data, then attempt to send it to the API
    config Config object
    dry Boolean should this just be a dry run, (ie collect but don't send metrics)
  """

  # Get the metrics
  metrics = Metrics(config, dry).get();

  # Create an instance of the runner, this
  # will run all the metrics passed in
  r = Runner(metrics)

  # load the cache
  cache = Cache(DEFAULT_TMP_DIR + '/hostplot.cache')

  metrics = r.run()
  if cache.has_cache() is True:
    metrics.update(cache.cache_get())

  data = {"metrics": metrics, "uuid": config.get('uuid')}

  if dry is not True:
    # returned data
    api = HostApi(config)
    response = api.saveHostMetrics(data)
    if response is None:
      print "Metrics not saved, transmission issues"
      cache.cache_save(metrics)
    else:
      if cache.has_cache() is True:
        cache.cache_clear()
  else:
    print data

def main(opts, args):
  """
  Application main loop
    opts OptParse opts
    args OptParse args
  """
  if opts.metric is not None:
    debug("Running custom metric [" + opts.metric + "]", DEBUG_DEBUG)
    if opts.metric_data is not None:
      debug("Metrics using provided data [" + opts.metric_data + "]", DEBUG_DEBUG)
      data = opts.metric_data
    else:
      data = None

    metrics = {}
    metrics['key'] = str(opts.metric)
    metrics['data'] = data
    metric = Runner([metrics])
    print metric.run();
    return True;

  if opts.config is not None:
    debug("Config specified ["+opts.config+"]", DEBUG_DEBUG)
    config_file = opts.config
  else:
    debug("No config specified using, default ["+DEFAULT_CONFIG_FILE+"]", DEBUG_DEBUG)
    config_file = DEFAULT_CONFIG_FILE

  # attempt to create the config
  try:
    config = Config.Config(config_file)
    debug("Opened config options", DEBUG_DEBUG)
  except:
    print "Config file doesn't exist and/or is not writable"
    return False

  # letc check if the config is new and if so set some config defaults
  if config.exists() is False:
    debug("Config file is new so setting default values", DEBUG_DEBUG)
    # add api info
    config.add('protocol', DEFAULT_API_PROTOCOL,'api')
    config.add('host', DEFAULT_API_SERVER, 'api')
    config.add('host_path', DEFAULT_API_HOST_PATH, 'api')
    config.add('metric_path', DEFAULT_API_METRIC_PATH, 'api')

    # add metric info
    config.add('metrics_ttl', DEFAULT_METRIC_TTL, 'config')
    config.add('metrics_last', "0", 'config')

  if opts.init is not None:
    debug("Running initialize", DEBUG_DEBUG)
    # initialize the host code
    try:
      config.add('code', opts.init)
      debug("Initializing for code [" + opts.init + "]", DEBUG_DEBUG)
      initialize(config)
    except:
      print "Failed to initialize the host with code " + opts.init
      return False

    print 'Host is now active, please set up the following CRON job:\n\n'
    print '*\t*\t*\t*\t*\tpython ' +  __file__ + '/' + DEFAULT_APP_NAME + ' -c ' + config_file + '\n\n'

    debug("Host initialized saving config", DEBUG_DEBUG)
    config.save()
    return True
  elif opts.run is not None:
    # run a custom "GET" query
    try:
      debug("Running custom command [" + opts.run + "]", DEBUG_DEBUG)
      run_command(opts.run, config)
      return True
    except:
      return False
  elif opts.update is not None:
    try:
      update(config)
      return True
    except:
      return False
  else:
    dry = False
    if opts.dry is not None:
      dry = True

    try:
      collect(config, dry)
      return True
    except:
      return False


if __name__ == "__main__":
  # parse cmd line arguments
  parser = optparse.OptionParser()
  parser.add_option('-i', '--init', help='Install and initialise host', dest='init')
  parser.add_option('-r', '--run', help='Run custom host GET command and output the results', dest='run')
  parser.add_option('-u', '--update', action="store_true",  dest='update', help='Check for updates')
  parser.add_option('-m', '--metric', dest='metric', help='Don\'t bootstrap, run a metric locally, and see the output')
  parser.add_option('-d', '--data', dest='metric_data', help='Optional data param for metrics')

  parser.add_option('-c', '--config', help='Config file to use', dest='config')
  parser.add_option('-f', '--fake-run', action="store_true", dest='dry', help='Dry run (no communication with server)')
  parser.add_option('-D', '--debug', help='Choose a debug level', dest='debug')
  (opts, args) = parser.parse_args()

  if opts.debug is not None:
    DEBUG_LEVEL = int(opts.debug)

  if main(opts, args) is True:
    debug("Success", DEBUG_DEBUG)
    exit(0)
  else:
    debug("Failed", DEBUG_DEBUG)
    exit(1)
